Описание макросов используемых в учебном курсе
==============================================

## Общая информация

Макросы подключаются путём указания в начале файла с ассемблерным кодом
_include console.inc_. На самом деле сама реализация макросов лежит в каталоге 
_include_ в файле _io.inc_.

Имя макрокоманды не является служебным именем, поэтому большие и маленькие буквы 
в них различаются, однако для удобства программирования при описании соответствующих
макроопределений иногда объявлены синонимы таких имён, например, 
у имени макрокоманды **gotoxy** есть синонимы **gotoXY** и **GotoXY**.

Все макрокоманды вывода (**outchar**, **outint**, **outstr**, **gotoxy**, **msgbox** и др.)
не портят регистры и флаги. Макрокоманды ввода (**inchar**, **inint**, **readkey** и др.)
не изменяют регистры (за исключением тех, на которых они возвращают результат),
флаги меняет только макрокоманда **inint**, она устанавливает определённые флаги 
в соответствие с результатом своей работы.

### exit - макрокоманда выхода из программы

Формат: **exit**

Действие этой макрокоманды эквивалентно выходу на завершающей _end._ в программе на Паскале.
Макрокоманда **exit** немедленно завершает выполняющуюся программу. Если программа была 
запущена не из консоли (консольного окна), весь вывод тут же будет потерян. Поэтому при запуске 
программы на счёт из Windows Explorer, непосредственно указывая в окошке с "папками" и 
файлами исполняемый файл _.exe_, полезно перед этой макрокомандой поставить 
либо макрокоманду **pause** для задержки окончания работы программы, 
либо выдавать окно сообщений **MsgBox**.

Следует помнить, что любая ассембленрная программа должна в конце концов вызвать системный вызов
_exit_, обращение к которому как-раз реализовано внутри макроса _exit_.     

### ClrScr - макрокоманда очистки окна консоли

Формат: **ClrScr**

Она эквивалентна вызову процедуры **ClrScr** языка _Free Pascal_.
Имеет короткий синоним **Cls**.

### ConsoleTitle - макрокоманда задания заголовка окна консоли

Формат: **ConsoleTitle** _Title_

Эта макрокоманда меняет заголовок консольного окна. Текст заголовка
используется диспетчером задач (процессов) Windows для идентификации
задачи в списке выполняемых приложений.
В качестве параметра может использоваться как непосредственный
операнд-текст, так и адрес текста.

Например:

```assembler
.data
    T  db "Заголовок 'окна' консоли",0
.code
    ConsoleTitle 'Don''t use " symbol !'
    ConsoleTitle offset
```

### outstr, outstrln - макрокоманда вывода строки текста

Формат: **outstr**[**ln**] _text_

Эта макрокоманда выводит на экран строку текста, определяемую
своим параметром. В качестве параметра может использоваться как
непосредственный операнд-текст, так и адрес текста.

Как и в Паскале, добавление к имени макрокоманды окончания 
_ln_ приводит к переходу после вывода на начало новой строки.

Например:

```assembler
.data
    T db "Hello, ""World"" !",0 ;Текст: Hello, "World" !,0
.code
    outstrln "Привет, мир!"
    outstr   offset T
    mov      eax, offset T
    outstr   eax
    outstrln 'Don''t do that!'
    lea      eax, T[7]
    outstrln eax ;Вывод "World" !
```

Текст может заключаться как в двойные, так и в одинарные кавычки (апострофы).
В строку выводимого текста можно вставлять через запятые 
числовые коды любых символов, например:

```assembler
outstr "Первая строка",13,10,"Новая строка = ",3Eh
```

### inputstr - макрокоманда ввода строки

Формат: **inputstr** _buf_, _Len_ [,_text_]

Макрокоманда вводит одну строку со стандартного потока ввода.
В качестве первого параметра задаётся адрес буфера для ввода текста,
а в качестве второго параметра (в формате i32, r32 или m32) – максимально допустимая 
длина вводимого текста. В качестве необязательного третьего параметра можно задать 
строку-приглашение ко вводу, формат этого последнего параметра такой же,
как и в макрокоманде **outstr**.

В буфер помещается текст из стандартного потока _stdin_ длиной не более _Len_ или до 
конца введённой строки (без символов конца строки #13 и #10). Текст в буфере будет
заканчиваться нулевым символом, поэтому длина буфера должна быть по крайней мере 
на единицу больше _Len_. Действие этой макрокоманды похоже на ввод строки S 
в языке _Free Pascal_:

```pascal
var S:string[buf-1];
```
Реальное число введённых символов (без учёта нулевого символа) 
возвращается на регистре EAX, например:

```assembler
.data
    Buf db 128 dup (?)
    T   db "Текст не длиннее 127 символов=",0
.code
    inputstr offset Buf, 128, offset T
    outwordln eax,, "Длина введённого текста="
```

### inchar - макрокоманда ввода символа с клавиатуры

Формат: **inchar** _op1_[,_text_]

**Ограничение**: при макроподстановке выводится фатальная диагностика об ошибке
при попытке  ввода в регистр-указатель вершины стека. Недопустимо:
```assembler
 inchar [e]sp
```

Вводит в буферизованном режиме один символ с клавиатуры. То есть вводится 
текст до перевода строки, а затем по символьно выдаётся программе.

Операнд _op1_ может иметь формат r8 или m8. 
Код (номер в алфавите) введённого символа записывается 
в место памяти, определяемое операндом _op1_. Эта макрокоманда эквивалентна
оператору языка _Free Pascal_ для ввода одного символа _Read(op1)_.
В качестве необязательного второго параметра можно задать строку-приглашение ко вводу,
формат этого последнего параметра такой же, как и в макрокоманде **outstr**.
Как обычно, из конца текстовой строки будут введены символы #13 и #10,
а символы из дополнительного алфавита предваряются символом #0.

Если по внешнему виду операнда нельзя установить его тип 
(и, следовательно, размер в байтах), то Ассемблер требует явно указать 
тип оператором **ptr**, например:

```assembler
.data
    x  db  ?
.code
    inchar x, "Введите один символ = "
    mov    ebx, offset x  ;ebx:=(адрес x)
    inchar byte ptr [ebx] ;нельзя просто [ebx]
```

### Readkey - макрокоманда ввода символа без эха и контроля

Формат: **Readkey** [_text_]

Выдаёт код (номер в алфавите) введённого символа. Код символа 
возвращается в регистре AL. Эта макрокоманда эквивалентна вызову функции
```pascal
AL:=ReadKey
``` 
языка _Free Pascal_. В качестве необязательного параметра можно задать
строку-приглашение к вводу, формат этого последнего параметра такой же,
 как и в макрокоманде **outstr**.  Стоит напомнить, что,
 как и в языке _Free Pascal_, символы из дополнительного алфавита 
поступают в виде двух символов: символа с номером ноль и символа из 
дополнительного алфавита. Например, при нажатии клавиши _F1_ сначала **ReadKey**
считает символ #0, а затем символ #59 (';') – это код клавиши _F1_ в дополнительном 
алфавите.

### outchar, outcharln - макрокоманда вывода символа на экран

Формат: **outchar**[**ln**] _op1_[,_text_]

**Ограничение**: К сожалению, пока макрокоманда работает неправильно,
при использовании регистра ESP как базового,
например:
```assembler
outchar byte ptr [esp]
```
надо производить в две команды, например:
```assembler
mov al,[esp]
outchar al
```

Печатает символ на стандартный поток вывода. Операнд _op1_ может 
иметь формат i8, r8 или m8. Значение операнда трактуется как беззнаковое число,
являющееся кодом (номером) символа в алфавите, этот символ выводится в текущую
позицию экрана.
В качестве необязательного второго параметра можно задать текстовую строку,
которая выводится перед символом, формат этого последнего параметра такой же,
как и в макрокоманде **outstr**.

Как и в Паскале, добавление к имени макрокоманды окончания **ln** приводит к переходу
после вывода на начало новой строки.

Для задания кода символа удобно использовать символьную константу языка 
Ассемблер (например, _'A'_), тогда можно не задаваться вопросом о соответствии
самих символов и их номеров в используемом алфавите. Такая константа преобразуется
компилятором Ассемблера именно в код этого символа, т.е. конструкция _'A'_ полностью
эквивалентна записи _ord('A')_ языка Паскаль. Например, макрокоманда
**outchar** _'*'_  выведет символ звёздочки на место курсора.
Другими словами, макрокоманда **outchar** эквивалентна оператору Паскаля для
вывода одного символа _Write(op1)_.



### ConsoleMode - макрокоманда переключения режима ввода

Формат: **ConsoleMode**

Включает и выключает перекодирование вводимого текста между кодировками
cp866/сp1251. По умолчанию режим такой, какой он есть в Windows, обычно cp866.

Например:

```assembler
.data
    buf db 128 dup (?)
.code
    inputstr offset Buf,127,"Введите русский текст :"
    outstrln "Введён текст :"
    ConsoleMode ;         Отключить перекодировку в DOS
    outstrln offset Buf
    ConsoleMode ;         Включить перекодировку в DOS
```


