Описание макросов используемых в учебном курсе
==============================================

## Оглавление

 1. [Общая информация](#Общая-информация)
 2. [Список макрокоманд](#Список-макрокоманд)
    1.  [exit - макрокоманда выхода из программы](#exit---макрокоманда-выхода-из-программы)
    2.  [ClrScr - макрокоманда очистки окна консоли](#ClrScr---макрокоманда-очистки-окна-консоли)
    3.  [ConsoleTitle - макрокоманда задания заголовка окна консоли](#ConsoleTitle---макрокоманда-задания-заголовка-окна-консоли)
    4.  [outstr, outstrln - макрокоманда вывода строки текста](#outstr-outstrln---макрокоманда-вывода-строки-текста)
    5.  [inputstr - макрокоманда ввода строки](#inputstr---макрокоманда-ввода-строки)
    6.  [inchar - макрокоманда ввода символа с клавиатуры](#inchar---макрокоманда-ввода-символа-с-клавиатуры)
    7.  [Readkey - макрокоманда ввода символа без эха и контроля](#Readkey---макрокоманда-ввода-символа-без-эха-и-контроля)
    8.  [outchar, outcharln - макрокоманда вывода символа на экран](#outchar-outcharln---макрокоманда-вывода-символа-на-экран)
    9.  [inint, inintln - макрокоманда ввода целого числа](#inint-inintln---макрокоманда-ввода-целого-числа)
    10. [outint, outintln и outword, outwordln - макрокоманды вывода целого значения](#outint-outintln-и-outword-outwordln---макрокоманды-вывода-целого-значения)
    11. [newline - макрокоманда перехода на новую строку](#newline---макрокоманда-перехода-на-новую-строку)
    12. [flush - макрокоманда очистки буфера ввода](#flush---макрокоманда-очистки-буфера-ввода)
    13. [pause - макрокоманда задания паузы с ожиданием ввода](#pause---макрокоманда-задания-паузы-с-ожиданием-ввода)
    14. [ConsoleMode - макрокоманда переключения режима ввода](#ConsoleMode---макрокоманда-переключения-режима-ввода)
    15. [GotoXY - макрокоманда перемещения курсора](#GotoXY---макрокоманда-перемещения-курсора)
    16. [WhereX, WhereY - макрокоманды определения позиции курсора](#WhereX-WhereY---макрокоманды-определения-позиции-курсора)
    17. [SetTextAttr - макрокоманда смены текущих цветов фона и символов](#SetTextAttr---макрокоманда-смены-текущих-цветов-фона-и-символов)
    18. [MsgBox - макрокоманда вывода окна сообщения](#MsgBox---макрокоманда-вывода-окна-сообщения)
 3. [Дополнительные макрокоманды для продвинутого уровня обучения](#Дополнительные-макрокоманды-для-продвинутого-уровня-обучения)
    1.  [new - макрокоманда порождения динамической переменной](#new---макрокоманда-порождения-динамической-переменной)


## Общая информация

Макросы подключаются путём указания в начале файла с ассемблерным кодом
_include console.inc_. На самом деле сама реализация макросов лежит в каталоге 
_include_ в файле _io.inc_.

Имя макрокоманды не является служебным именем, поэтому большие и маленькие буквы 
в них различаются, однако для удобства программирования при описании соответствующих
макроопределений иногда объявлены синонимы таких имён, например, 
у имени макрокоманды **gotoxy** есть синонимы **gotoXY** и **GotoXY**.

Все макрокоманды вывода (**outchar**, **outint**, **outstr**, **gotoxy**, **msgbox** и др.)
не портят регистры и флаги. Макрокоманды ввода (**inchar**, **inint**, **readkey** и др.)
не изменяют регистры (за исключением тех, на которых они возвращают результат),
флаги меняет только макрокоманда **inint**, она устанавливает определённые флаги 
в соответствие с результатом своей работы.

## Список макрокоманд

### exit - макрокоманда выхода из программы

Формат: **exit**

Действие этой макрокоманды эквивалентно выходу на завершающей _end._ в программе на Паскале.
Макрокоманда **exit** немедленно завершает выполняющуюся программу. Если программа была 
запущена не из консоли (консольного окна), весь вывод тут же будет потерян. Поэтому при запуске 
программы на счёт из Windows Explorer, непосредственно указывая в окошке с "папками" и 
файлами исполняемый файл _.exe_, полезно перед этой макрокомандой поставить 
либо макрокоманду **pause** для задержки окончания работы программы, 
либо выдавать окно сообщений **MsgBox**.

Следует помнить, что любая ассембленрная программа должна в конце концов вызвать системный вызов
_exit_, обращение к которому как-раз реализовано внутри макроса **exit**.     

### ClrScr - макрокоманда очистки окна консоли

Формат: **ClrScr**

Она эквивалентна вызову процедуры **ClrScr** языка _Free Pascal_.
Имеет короткий синоним **Cls**.

### ConsoleTitle - макрокоманда задания заголовка окна консоли

Формат: **ConsoleTitle** _Title_

Эта макрокоманда меняет заголовок консольного окна. Текст заголовка
используется диспетчером задач (процессов) Windows для идентификации
задачи в списке выполняемых приложений.
В качестве параметра может использоваться как непосредственный
операнд-текст, так и адрес текста.

Например:

```assembler
.data
    T  db "Заголовок 'окна' консоли",0
.code
    ConsoleTitle 'Don''t use " symbol !'
    ConsoleTitle offset
```

### outstr, outstrln - макрокоманда вывода строки текста

Формат: **outstr**[**ln**] _text_

Эта макрокоманда выводит на экран строку текста, определяемую
своим параметром. В качестве параметра может использоваться как
непосредственный операнд-текст, так и адрес текста.

Как и в Паскале, добавление к имени макрокоманды окончания 
_ln_ приводит к переходу после вывода на начало новой строки.

Например:

```assembler
.data
    T db "Hello, ""World"" !",0 ;Текст: Hello, "World" !,0
.code
    outstrln "Привет, мир!"
    outstr   offset T
    mov      eax, offset T
    outstr   eax
    outstrln 'Don''t do that!'
    lea      eax, T[7]
    outstrln eax ;Вывод "World" !
```

Текст может заключаться как в двойные, так и в одинарные кавычки (апострофы).
В строку выводимого текста можно вставлять через запятые 
числовые коды любых символов, например:

```assembler
outstr "Первая строка",13,10,"Новая строка = ",3Eh
```

### inputstr - макрокоманда ввода строки

Формат: **inputstr** _buf_, _Len_ [,_text_]

Макрокоманда вводит одну строку со стандартного потока ввода.
В качестве первого параметра задаётся адрес буфера для ввода текста,
а в качестве второго параметра (в формате i32, r32 или m32) – максимально допустимая 
длина вводимого текста. В качестве необязательного третьего параметра можно задать 
строку-приглашение ко вводу, формат этого последнего параметра такой же,
как и в макрокоманде **outstr**.

В буфер помещается текст из стандартного потока _stdin_ длиной не более _Len_ или до 
конца введённой строки (без символов конца строки #13 и #10). Текст в буфере будет
заканчиваться нулевым символом, поэтому длина буфера должна быть по крайней мере 
на единицу больше _Len_. Действие этой макрокоманды похоже на ввод строки S 
в языке _Free Pascal_:

```pascal
var S:string[buf-1];
```
Реальное число введённых символов (без учёта нулевого символа) 
возвращается на регистре EAX, например:

```assembler
.data
    Buf db 128 dup (?)
    T   db "Текст не длиннее 127 символов=",0
.code
    inputstr offset Buf, 128, offset T
    outwordln eax,, "Длина введённого текста="
```

### inchar - макрокоманда ввода символа с клавиатуры

Формат: **inchar** _op1_[,_text_]

**Ограничение**: при макроподстановке выводится фатальная диагностика об ошибке
при попытке  ввода в регистр-указатель вершины стека. Недопустимо:
```assembler
 inchar [e]sp
```

Вводит в буферизованном режиме один символ с клавиатуры. То есть вводится 
текст до перевода строки, а затем по символьно выдаётся программе.

Операнд _op1_ может иметь формат r8 или m8. 
Код (номер в алфавите) введённого символа записывается 
в место памяти, определяемое операндом _op1_. Эта макрокоманда эквивалентна
оператору языка _Free Pascal_ для ввода одного символа _Read(op1)_.
В качестве необязательного второго параметра можно задать строку-приглашение ко вводу,
формат этого последнего параметра такой же, как и в макрокоманде **outstr**.
Как обычно, из конца текстовой строки будут введены символы #13 и #10,
а символы из дополнительного алфавита предваряются символом #0.

Если по внешнему виду операнда нельзя установить его тип 
(и, следовательно, размер в байтах), то Ассемблер требует явно указать 
тип оператором **ptr**, например:

```assembler
.data
    x  db  ?
.code
    inchar x, "Введите один символ = "
    mov    ebx, offset x  ;ebx:=(адрес x)
    inchar byte ptr [ebx] ;нельзя просто [ebx]
```

### Readkey - макрокоманда ввода символа без эха и контроля

Формат: **Readkey** [_text_]

Выдаёт код (номер в алфавите) введённого символа. Код символа 
возвращается в регистре AL. Эта макрокоманда эквивалентна вызову функции
```pascal
AL:=ReadKey
``` 
языка _Free Pascal_. В качестве необязательного параметра можно задать
строку-приглашение к вводу, формат этого последнего параметра такой же,
 как и в макрокоманде **outstr**.  Стоит напомнить, что,
 как и в языке _Free Pascal_, символы из дополнительного алфавита 
поступают в виде двух символов: символа с номером ноль и символа из 
дополнительного алфавита. Например, при нажатии клавиши _F1_ сначала **ReadKey**
считает символ #0, а затем символ #59 (';') – это код клавиши _F1_ в дополнительном 
алфавите.

### outchar, outcharln - макрокоманда вывода символа на экран

Формат: **outchar**[**ln**] _op1_[,_text_]

**Ограничение**: К сожалению, пока макрокоманда работает неправильно,
при использовании регистра ESP как базового,
например:
```assembler
outchar byte ptr [esp]
```
надо производить в две команды, например:
```assembler
mov al,[esp]
outchar al
```

Печатает символ на стандартный поток вывода. Операнд _op1_ может 
иметь формат i8, r8 или m8. Значение операнда трактуется как беззнаковое число,
являющееся кодом (номером) символа в алфавите, этот символ выводится в текущую
позицию экрана.
В качестве необязательного второго параметра можно задать текстовую строку,
которая выводится перед символом, формат этого последнего параметра такой же,
как и в макрокоманде **outstr**.

Как и в Паскале, добавление к имени макрокоманды окончания **ln** приводит к переходу
после вывода на начало новой строки.

Для задания кода символа удобно использовать символьную константу языка 
Ассемблер (например, _'A'_), тогда можно не задаваться вопросом о соответствии
самих символов и их номеров в используемом алфавите. Такая константа преобразуется
компилятором Ассемблера именно в код этого символа, т.е. конструкция _'A'_ полностью
эквивалентна записи _ord('A')_ языка Паскаль. Например, макрокоманда
**outchar** _'*'_  выведет символ звёздочки на место курсора.
Другими словами, макрокоманда **outchar** эквивалентна оператору Паскаля для
вывода одного символа _Write(op1)_.

### inint, inintln - макрокоманда ввода целого числа

Формат: **intint**[_ln_] _op1_[,_text_]

Считывает число в текстовом виде со стандартного потока ввода, 
преобразуя его в машинный формат. В качестве первого операнда _op1_ можно 
использовать форматы r8, r16, r32, m8, m16 или m32. 
В качестве необязательного второго операнда можно задать строку-приглашение ко вводу,
формат этого последнего параметра такой же, как и в макрокоманде **outstr**. 

Добавление к имени макрокоманды окончания ln приводит 
к очистке буфера ввода после чтения и 
эквивалентно вызову стандартной процедуры _Readln_ языка Паскаль.

Макрокоманда вводит из стандартного потока на место первого операнда любое целое 
значение из диапазона –2^31..+2^32–1 (этот диапазон является объединением 
диапазонов знаковых и беззнаковых чисел формата двойного слова dd).
При выходе вводимого значения за максимальный диапазон двойного слова
макрокоманда выдаёт (предупредительную) диагностику об ошибке:
```
** inint: Number too big:=MaxLongint, CF:=1 **
```
При этом операнду присваивается значение **7FFFFFFFh** (_MaxLongint_).
Такой же результат будет и при явно заданном знаке минус и абсолютном значении 
введённого числа больше, чем **80000000h** (_MaxLongword_).

В случае, если введённое число превышает размер операнда _op1_,
то производится усечение этого числа без выдачи диагностики об ошибке.

Макрокоманда выставляет флаг _CF:=0_ при правильном вводе и _CF:=1_ при неправильном.
Для правильного числа  также устанавливается флаг _ZF:=1_, если лексема введённого 
числа начиналась со знака "–", иначе _ZF:=0_.

В отличие от Паскаля, где ограничителем лексемы целого значения во входном потоке 
является символ пробела, табуляции или конец строки, макрокоманда **inint** 
дополнительно считает концом целой лексемы любой символ, не являющийся цифрой.
В такого "плохого" конца лексемы целого числа (когда конец был не пробельным символом)
при возврате устанавливается флаг _SF:=1_, иначе SF:=0.

Например, из строки "–123ABCD" введётся число –123, во входном 
потоке останется строка "BCD", при этом будет: _SF:=1_, _ZF:=1_ и _CF:=0_.

Пример:

```assembler
.data
    X  dd  ?
.code
    inint X, "Введите целое число X="
    jc    BigNum  ;Число вне допустимого диапазона
    jz    Minus   ;Введено число со знаком минус
    js    BadEnd  ;Плохое окончание числа
```

### outint, outintln и outword, outwordln - макрокоманды вывода целого значения

Формат:
   * **outint**[**ln**]  _op1_\[,\[_op2_\]\[,_text_\]\]
   * **outword**[**ln**] _op1_\[,\[_op2_\]\[,_text_\]\]

Здесь, как всегда при описании синтаксиса, квадратные скобки говорят о том,
какие части макрокоманды можно опустить. В качестве первого операнда _op1_ можно
использовать форматы r8, r16, r32, m8, m16, m32, m64 или i32,
а в качестве необязательного второго – форматы i8, r8 или m8.
В качестве необязательного третьего параметра можно задать текстовую строку,
которая выводится перед целым числом, 
формат этого последнего параметра такой же, как и в макрокоманде **outstr**.

При невозможности определить тип выводимого значения предполагается dd,
например,  **outint** \[_ebx_\]  выводится как  **outint** _dword ptr_ \[_ebx_\] .

Макрокоманда **outint** имеет короткие синонимы **OutI** и **outi**. 
Действие же макрокоманды с именем **outword** отличается только тем, что 
первый операнд при выводе трактуется как беззнаковое (неотрицательное) целое число.
Эта макрокоманда имеет синоним **OutUnsigned** или более коротко **OutU** и **outu**.

Как и в Паскале, добавление к имени макрокоманды окончания **ln** (или **Ln**) приводит
к переходу после вывода на начало новой строки.

Действие макрокоманды  **outint** _op1_\[,\[_op2_\]\[,_text_\]\]  эквивалентно выполнению 
процедуры вывода одного знакового целого значения в языке 
Паскаль _Write(\[text,\]op1\[:op2\])_, где параметр _op2_ задаёт ширину поля вывода.
При _op2 < 0_ в качестве ширины поля вывода берётся абсолютная величина _op2_,
но выводимые данные выравниваются не по правому, а по левому краю поля вывода.

Пример:

```assembler
.data
    x  dd  ?
.code
    inint x
    outintln x, 10, "Введено x="
    outwodln esp,,  "Адрес вершины стека="
    outu [esp],,    "Адрес возврата="
    OutU -1, -12,   "MaxLongWord="
```
### newline - макрокоманда перехода на новую строку

Формат: **newline** [_n_]

Макрокоманда предназначена для перевода курсора к началу следующей строки 
экрана и эквивалентна вызову _n_ раз стандартной процедуры без 
параметров _Writeln_ языка Паскаль. По умолчанию _n=1_.

### flush - макрокоманда очистки буфера ввода

Формат: **flush**

**Ограничение**: 
    к сожалению, пока макрокоманда работает неправильно, если буфер ввода уже совсем пуст
   (не содержит концевого служебного символа LF, уже введённого, например, по **inchar**).

Макрокоманда предназначена для очистки буфера ввода и 
эквивалентна вызову стандартной процедуры без параметров _Readln_ языка Паскаль.
По сути макрокоманда считывает символы со стандартного ввода и выкидывает их в никуда,
до тех пор, пока не наткнётся на конец строки.

### pause - макрокоманда задания паузы с ожиданием ввода

Формат: **pause** [_text_]

Макрокоманда приостанавливает выполнение программы до появления данных в потоке ввода
("нажатия клавиши на клавиатуре"). В качестве необязательного параметра можно 
использовать как непосредственный операнд-текст, так и адрес текста, например:
```assembler
pause "Для продолжения нажмите любую клавишу…"
```

### ConsoleMode - макрокоманда переключения режима ввода

Формат: **ConsoleMode**

Включает и выключает перекодирование вводимого текста между кодировками
cp866/сp1251. По умолчанию режим такой, какой он есть в Windows, обычно cp866.

Например:

```assembler
.data
    buf db 128 dup (?)
.code
    inputstr offset Buf,127,"Введите русский текст :"
    outstrln "Введён текст :"
    ConsoleMode ;         Отключить перекодировку в DOS
    outstrln offset Buf
    ConsoleMode ;         Включить перекодировку в DOS
```

### GotoXY - макрокоманда перемещения курсора

Формат: **GotoXY** _x_,_y_

Параметры _x_ и _y_ могут быть форматов r8, r16, m8, m16 или i8.
Действие этой макрокоманды эквивалентно выполнению оператора процедуры _GotoXY(x,y)_
языка Free Pascal для окна консоли. При выходе _x_ и/или _y_ за границы окна 
курсор не перемещается.

### WhereX, WhereY - макрокоманды определения позиции курсора

Формат: 
    * **WhereX**
    * **WhereY**

Макрокоманда возвращает для **WhereX** номер столбца позиции курсора (1..80) и 
для **WhereY** номер строки в окне консоли. Обычно окно консоли создаётся длиной 50 строк 
(с возможностью прокрутки текста). Результат возвращается в регистре AL.
 Эта макрокоманда эквивалентна вызову функции _AL:=WhereX_ языка _Free Pascal_.

### SetTextAttr - макрокоманда смены текущих цветов фона и символов

Формат: **SetTextAttr** [_colors_]

Макрокоманда переключает цвет символа и фона, на котором печатается символ.
Цвета задаются в палитре из 16 цветов, как и в языке _Free Pascal_, 
задаются в параметре формата i8 в виде _16*\<цвет фона\>+\<цвет букв\>_.

Определены имена следующих констант цветов:

цвет         |    значение            
-------------|----------------------
Black        | 0h                     
Blue         | 1h                     
Green        | 2h                     
Red          | 4h                     
Bright       | 8h                     
DarkGray     | Bright                 
Cyan         | Blue+Green             
Brown        | Green+Red              
Magenta      | Blue+Red               
LightMagenta | Bright+Blue+Red        
LightGray    | Blue+Green+Red         
LightBlue    | Bright+Blue            
LightGreen   | Bright+Green           
LightRed     | Bright+Red             
Yellow       | Bright+Green+Red       
White        | Bright+Blue+Green+Red  

При отсутствии параметра подразумевается выставление цвета _LightGray_.
Действие макрокоманды эквивалентно (за исключением случая пустого параметра)
оператору присваивания языка _Free Pascal_
```pascal
TextAttr := colors
```

Примеры:
```assembler
SetTextAttr 16*Blue+Yellow
OutStrLn "Цвет=16*Blue+Yellow"
SetTextAttr Blue
OutStrLn 'Цвет=16*Black+Blue'
SetTextAttr
OutStrLn 'Цвет=16*Black+LightGray'
```

### MsgBox - макрокоманда вывода окна сообщения

Формат: **MsgBox** _Caption_,_Message_[,_Style_]

Эта макрокоманда выводит на экран (поверх остальных окон)
небольшое окно сообщения с текстом заголовка _Caption_, текстом 
сообщения _Message_ и кнопками ответов.
Пиктограмма окна сообщений, количество и вид кнопок определяется 
стилем окна _Style_. Стиль окна определяется набором (суммой)
битовых признаков, которым присвоены мнемонические имена из 
таблицы далее. Когда стиль опущен, предполагается MB\_OK.

Имя                   | Поведение
----------------------|----------------------------------------------
MB\_OK                | кнопка "OK"
MB\_OKCANCEL          | кнопки "OK" и "Отмена"
MB\_ABORTRETRYIGNORE  | кнопки "Прервать", "Повтор" и "Пропустить"
MB\_YESNOCANCEL       | кнопки "Да", "Нет" и "Отмена"
MB\_YESNO             | кнопки "Да" и "Нет"
MB\_RETRYCANCEL       | кнопки "Повтор" и "Отмена",
MB\_CANCELTRYCONTINUE | кнопки "Отмена", "Повторить" и "Продолжить"

Пиктограмма окна задаётся битовым признаком:

Имя                  | Иконка
---------------------|-----------------------------------------------------------------------
MB\_ICONSTOP         | ![stop](pic/stop.jpg)
MB\_ICONQUESTION     | ![quest](pic/quest.png)
MB\_ICONEXCLAMATION  | ![notify](pic/notify.jpg) обычно здесь выдаётся ещё и звуковой сигнал
MB\_ICONASTERISK     | ![info](pic/info.png)
MB\_USERICON         | без пиктограммы (можно сделать свой _.ico_ файл)

При нажатии на кнопку в регистре _EAX_ возвращается код нажатой кнопки.
Мнемонические имена этих кодов:
_IDOK_, _IDCANCEL_ (также, если нажать клавишу _ESC_ или крестик закрытия окна),
_IDABORT_, _IDRETRY_, _IDIGNORE_, _IDYES_, _IDNO_, _IDTRYAGAIN_, _IDCONTINUE_

При вводе из окна по умолчанию выбирается (если просто нажать ENTER) первая по 
порядку из выведенных кнопок, чтобы выбрать по умолчанию другую кнопку,
надо в параметре _Style_ задать битовый признак 
с номером кнопки в окне: _MB\_DEFBUTTON{1,2,3}_

В качестве параметров _Caption_ и _Message_ можно использовать
как непосредственный операнд-текст, так и адрес текста.

Пример:
```assembler
.data
    T1 db 'Текст заголовка окна', 0
    T2 db "Было хорошо ?", 0
.code
    MsgBox offset T1, "Привет, мир!", MB_OK+MB_ICONEXCLAMATION
    MsgBox 'Заголовок окна', offset T2, \
           MB_YESNO+MB_ICONQUESTION+MB_DEFBUTTON2 ; Пессимист
    
    cmp eax, DNO
    je  Bad_Chance
```

## Дополнительные макрокоманды для продвинутого уровня обучения

### new - макрокоманда порождения динамической переменной


